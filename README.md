<div align="center">
  <a href="https://www.linkedin.com/in/aminkhani-ai/" targert="_blacnk">
    <img src="https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" alt="LinkedIn Badge"/>
  <a href="mailto:aminkhani2010@gmail.com" targert="_blacnk">
    <img src="https://img.shields.io/badge/Gmail-D14836?style=for-the-badge&logo=gmail&logoColor=white" alt="Gmail Badge"/>
  </a>
  <a href="https://t.me/aminkhani_ai" targert="_blacnk">
    <img src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Badge"/>
  </a>  
  <a href="https://www.instagram.com/aminkhani_ai/" targert="_blacnk">
    <img src="https://img.shields.io/badge/Instagram-E4405F?style=for-the-badge&logo=instagram&logoColor=white" alt="Instagram Badge"/>
  </a>
  <a href="https://github.com/aminkhani/" targert="_blacnk">
    <img src="https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white" alt="Github Badge" />
  </a>
</div>
<br />
<div align="center">
  <h1 align="center">Formal Languages and Automata Theory (FLAT) Tutorial</h1>
  <img src="Pic/Flat.jpg">
  <p align="center"> 
    <br />
   <a href="https://github.com/aminkhani/Automata-Theory/issues/new?assignees=&labels=bug&template=bug_report.yml&title=%5BBUG%5D%3A+">üêõReport Bug</a>
   .
   <a href="https://github.com/aminkhani/Automata-Theory/issues/new?assignees=&labels=question&template=question.yml&title=%5BQUESTION%5D%3A+">‚ùìAsk Question</a>
   .
  <a href="https://github.com/aminkhani/Automata-Theory/issues/new?assignees=&labels=like&template=like.yml&title=%5BLIKE%5D%3A+">üëçLike the repo</a>
  .
  <a href="https://github.com/aminkhani/Automata-Theory/issues/new?assignees=&labels=unlike&template=unlike.yml&title=%5BUNLIKE%5D%3A+">üëéDislike the repo</a>
  </p>
  </p>
</div><br /><br />

</div>

> **Note**
>
> üì£ You can help to improve this repo, by giving me a **‚≠êstar‚≠ê** and **‚ù§Ô∏èfollowing me‚ù§Ô∏è**
> 
> **Warning**
> 
> It is better to use the web browser to view the math notation in this repository.
<br>

<h1 id="top">Contents</h1>
<h3>Prerequisite</h3>
<ul>
    <li><a href="#what_is_theory">Theory Definition</a></li>
    <li><a href="#scientific_theory">Scientific Theory Definition</a></li>
    <li><a href="#TCS">TCS</a>
        <ul>
            <li><a href="#algorithm">Algorithms</a></li>
            <li><a href="#ds">Data Structures</a></li>
            <li><a href="#complexity">Computational Complexity</a></li>
            <li><a href="#parallel">Parallel & Distributed Computation</a></li>
            <li><a href="#probab">Probabilistic Computation</a></li>
            <li><a href="#quantum">Quantum Computation</a></li>
            <li><a href="#auto_theory">Automata Theory</a></li>
            <li><a href="#info_theory">Information Theory</a></li>
            <li><a href="#crypto">Cryptography</a></li>
            <li><a href="#prog_seman">Program Semantics & Verification</a></li>
            <li><a href="#game_theory">Algorithmic Game Theory</a></li>
            <li><a href="#ML">Machine Learning</a></li>
            <li><a href="#biology">Computational Biology</a></li>
            <li><a href="#economi">Computational Economics</a></li>
            <li><a href="#geometry">Computational Geometry</a></li>
            <li><a href="#number">Computational Number Theory</a></li>
            <li><a href="#algebra">Algebra</a></li>
        </ul>
    </li>
</ul>
<h3 id=topp>The Tutorial</h3>
<ul>
  <li><a href="#formal_languages">Mathematical Preliminaries And Notation</a>
    <ul>
      <li><a href="#set">Sets</a>
        <ul>
          <li><a href="#union">Union</a></li>
          <li><a href="#intersection">Intersection</a></li>
          <li><a href="#difference">Difference</a></li>
          <li><a href="#complementation">Complementation</a></li>
          <li><a href="#empty">Empty Set</a></li>
          <li><a href="#deMorgan">DeMorgan‚Äôs laws</a></li>
          <li><a href="#subset">Subset</a></li>
          <li><a href="#proper">Proper Subset</a></li>
          <li><a href="#disjoint">Disjoint</a></li>
          <li><a href="#finite">Finite & Infinite</a></li>
          <li><a href="#powerset">Powerset</a></li>
          <li><a href="#cartesian">Cartesian Product</a></li>
          <li><a href="#partition">Partition</a></li>
        </ul>
      </li>
      <li><a href="#function">Functions and Relations</a>
      </li>
      <li><a href="#graphs">Graphs</a>
        <ul>
          <li><a href="#edge">Vertices & Edges</a></li>
          <li><a href="#walk">Walk</a></li>
          <li><a href="#path">Path & Simple Path</a></li>
          <li><a href="#cycle">Cycle</a></li>
        </ul>
      </li>
      <li><a href="#tree">Trees</a>
        <ul>
          <li><a href="#child">Parent & Child</a></li>
          <li><a href="#lvl">Level</a></li>
          <li><a href="#height">Height</a></li>
        </ul>
      </li>
      <li><a href="#proof">Proof Techniques</a>
        <ul>
          <li><a href="#proof1">Proof By Induction</a></li>
          <li><a href="#proof2">Proof By Contradiction</a></li>
        </ul>
      </li>
      <li><a href="#languages">Languages</a></li>
      <li><a href="#grammars">Grammars</a></li>
      <li><a href="#automata">Automata</a></li>
    </ul>
  </li>
</ul>

<h1 id="what_is_theory">What Is a Theory?</h1>

- In everyday use, the word **theory** often means an **untested hunch**, or a **guess** without **supporting evidence**. But for **scientists**, a theory has nearly the opposite meaning.
<br>

- A **theory** is a well-substantiated explanation of an aspect of the natural world that can incorporate **laws**, **hypotheses** and **facts**.
<br>

- **Theory** is a rational type of **abstract thinking** about a **phenomenon**, or the **results of such thinking**. The process of contemplative and rational thinking is often associated with such processes as observational study or research.

- The **theory of gravitation**, for instance, explains why apples fall from trees and astronauts float in space.
<br>

- In **modern science**, the term **theory** refers to **scientific theories**.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h1 id="scientific_theory">What Is a Scientific Theory?</h1>

- **Scientific theory** is an explanation of an aspect of the natural world and universe that has been **repeatedly tested** and **corroborated** in accordance with the **scientific method**, using accepted protocols of **observation**, **measurement**, and **evaluation** of results.
<br>

- A **scientific theory** differs from a **scientific fact** or **scientific law**, in that a **theory** explains **why** or **how**: a **fact** is a **simple**, **basic observation**, whereas a **law** is a **statement (often a mathematical equation)** about a relationship between **facts**.
<br>

- For example, **Newton‚Äôs Law of Gravity** is a **mathematical equation** that can be used to predict the attraction between bodies, but it is **not a theory** to explain **how gravity works**.
<br>

- **[Stephen Jay Gould wrote that](https://en.wikipedia.org/wiki/Stephen_Jay_Gould)** "...**facts** and **heories** are **different** things, not rungs in a hierarchy of increasing certainty. **Facts** are the world's data. **Theories** are structures of ideas that explain and interpret facts.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h1 id="TCS">Theoretical Computer Science (TCS)</h1>

- **Theoretical computer science (TCS)** is a subset of **general computer science** and **mathematics** that focuses on **mathematical aspects of computer science** such as the **theory of computation**, **lambda calculus**, and **type theory**.

## TCS covers a wide variety of topics including: 

<span id="algorithm"></span>

- ### [Algorithms](https://en.wikipedia.org/wiki/Algorithm)
  - An **algorithm** is a **step-by-step procedure for calculations**. **Algorithms** are used for **calculation**, **data processing**, and **automated reasoning**.
  <br>

  - An **algorithm** is an effective method expressed as a finite list of well-defined instructions for calculating a function. Starting from an initial state and initial input (perhaps empty).

<div align="right"><a href="https://en.wikipedia.org/wiki/Algorithm" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="ds"></span>

- ### [Data Structures](https://en.wikipedia.org/wiki/Data_structure)
  - **Data structure** is a **data organization**, **management**, and **storage format** that is usually chosen for efficient access to data.
  <br>

  - More precisely, a **data structure** is a **collection of data values**, the **relationships** among them, and the **functions or operations** that can be applied to the data


<div align="right"><a href="https://en.wikipedia.org/wiki/Data_structure" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="complexity"></span>

- ### [Computational Complexity Theory](https://en.wikipedia.org/wiki/Computational_complexity_theory)
  - Focuses on **classifying computational problems** according to their **resource usage**, and **relating** these classes to each other.
  <br>

  - A **computational problem** is a **task** solved by a **computer**. A **computation problem** is solvable by **mechanical application of mathematical steps**, such as an **algorithm**.

<div align="right"><a href="https://en.wikipedia.org/wiki/Computational_complexity_theory" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="parallel"></span>

- ### [Parallel](https://en.wikipedia.org/wiki/Parallel_computing) and [Distributed Computing](https://en.wikipedia.org/wiki/Distributed_computing)
  - **Parallel computing** is a **type of computation** in which many **calculations or processes** are carried out **simultaneously**.
  <br>

  - **Large problems** can often be divided into smaller ones, which can then be solved at the same time.


<div align="right"><a href="https://en.wikipedia.org/wiki/Parallel_computing" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="https://en.wikipedia.org/wiki/Distributed_computing" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="probab"></span>

- ### [Probabilistic Computation](https://en.wikipedia.org/wiki/Probabilistic_computation)
  

<div align="right"><a href="https://en.wikipedia.org/wiki/Probabilistic_computation" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="quantum"></span>

- ### [Quantum Computation](https://en.wikipedia.org/wiki/Quantum_computation)

<div align="right"><a href="https://en.wikipedia.org/wiki/Quantum_computation" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="auto_theory"></span>

- ### [Automata Theory]()

<div align="right"><a href="#" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="info_theory"></span>

- ### [Information Theory](https://en.wikipedia.org/wiki/Information_theory)


<div align="right"><a href="https://en.wikipedia.org/wiki/Information_theory" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="crypto"></span>

- ### [Cryptography](https://en.wikipedia.org/wiki/Cryptography)


<div align="right"><a href="https://en.wikipedia.org/wiki/Cryptography" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="prog_seman"></span>

- ### [Program Semantics](https://en.wikipedia.org/wiki/Program_semantics) and [Verification](https://en.wikipedia.org/wiki/Formal_methods)


<div align="right"><a href="https://en.wikipedia.org/wiki/Program_semantics" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="https://en.wikipedia.org/wiki/Formal_methods" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="game_theory"></span>

- ### [Algorithmic Game Theory](https://en.wikipedia.org/wiki/Algorithmic_game_theory)


<div align="right"><a href="https://en.wikipedia.org/wiki/Algorithmic_game_theory" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="ML"></span>

- ### [Machine Learning](https://en.wikipedia.org/wiki/Machine_learning)
  

<div align="right"><a href="https://en.wikipedia.org/wiki/Machine_learning" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="biology"></span>

- ### [Computational Biology](https://en.wikipedia.org/wiki/Computational_biology)
    

<div align="right"><a href="https://en.wikipedia.org/wiki/Computational_biology" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="economi"></span>

- ### [Computational Economics](https://en.wikipedia.org/wiki/Computational_economics)
    

<div align="right"><a href="https://en.wikipedia.org/wiki/Computational_economics" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="geometry"></span>

- ### [Computational Geometry](https://en.wikipedia.org/wiki/Computational_geometry)
    

<div align="right"><a href="https://en.wikipedia.org/wiki/Computational_geometry" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="number"></span>

- ### [Computational Number Theory](https://en.wikipedia.org/wiki/Computational_number_theory)


<div align="right"><a href="https://en.wikipedia.org/wiki/Computational_number_theory" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="algebra"></span>

- ### [Algebra](https://en.wikipedia.org/wiki/Algebra)
  

<div align="right"><a href="https://en.wikipedia.org/wiki/Algebra" targert="_blacnk"><img src="https://img.shields.io/badge/Read More-green?style=for-the-badge" /></a>
<a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h1 id="formal_languages">Mathematical Preliminaries And Notation</h1>
<span id="set"></span>

- # Sets

  - **Set** is a **collection of elements**, **without any structure** other than membership.
  <br>  

  - To indicate that **$x$** is an **element** of the **set** **$S$**, we write **$x ‚àà S$**.
  <br>

  - The statement that **$x$** is **not in** **$S$** is written **$x ‚àâ S$**.
  <br>

  - The **set of integers 0, 1, 2** is shown as: 
    - $S =\\{0, 1, 2\\}$
  <br>

  - **$S$** is the **set of** all **$i$**, such that **$i$** is **greater than zero**:
    - $S = \\{i : i > 0\\}$

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

- # Set Terms

<span id="union"></span>

- ## Union ( $\bigcup$ )
  - $S_1 \bigcup S_2 = \\{x : x ‚àà S_1 \mid\mid x ‚àà S_2\\}$

<span id="intersection"></span>

- ## Intersection ( $\bigcap$ )
  - $S_1 \bigcap S_2 = \\{x : x ‚àà S_1 \And x ‚àà S_2\\}$

<span id="difference"></span>

- ## Difference ( $-$ )
  - $S_1 ‚àí S_2 = \\{x : x ‚àà S_1 \And x ‚àâ S_2\\}$

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="complementation"></span>

- ## Complementation ( $\overline{S}$ )
  - The **complement** of a **set $S$**, is **$\overline{S}$** that consists of **all elements not in $S$**. 
  - **Universal set ( $U$ )**: **all possible elements**.
  <br>

  - $\overline{S} = \\{x : x ‚àà U, x ‚àâ S\\}$

<span id="empty"></span>

- ## Emtpy Set ( $\varnothing$ )
  - The **set** with **no elements**, called the **empty set** or the **null set**.
  <br>

  - $S \bigcup \varnothing = S ‚àí \varnothing = S$
  <br>

  - $S \bigcap \varnothing = \varnothing$
  <br>

  - $\overline{\varnothing} = U$ 

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="deMorgan"></span>

- ## DeMorgan‚Äôs laws
  - $\overline{S_1 \bigcup S_2} = \overline{S_1} \bigcap \overline{S_2}$
  <br>

  - $\overline{S_1 \bigcap S_2} = \overline{S_1} \bigcup \overline{S_2}$ 

<span id="subset"></span>

- ## Subset ( $\subseteq$ )
  - A **set** **$S_1$** is said to be a **subset** of **$S$** if **every element of** **$S_1$** is **also an element of** **$S$**:
    - $S_1 \subseteq S$

<span id="proper"></span>

- ## Proper Subset ( $\subset$ )
  - If **$S_1 \subseteq S$**, but **$S$** contains an **element not in** **$S_1$**, we say that **$S_1$** is a **proper subset** of **$S$**:
    - $S_1 \subset S$ 

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="disjoint"></span>

- ## Disjoint ( $\cap$ )
  - If **$S_1$** and **$S_2$** have **no common element**, that is, **$S_1 \bigcap S_2 = \varnothing$**, then the **sets** are said to be **disjoint**.

<span id="finite"></span>

- ## Finite & Infinite Set
  - A **set** is **finite** if it has **a finite number of elements**. The **size** of a **finite set** is the **number of elements** in it:
    - $|S|$

  <br>

  - A **set** is **infinite** if it has **an infinite number of elements**.

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="powerset"></span>

- ## Powerset ( $2^{|S|}$ )
  - The **set** of **all subsets of a set** **$S$**.
  - For example: $S = \\{a, b\\}$
  - $2^{|S|} =  \\{\varnothing, \\{a\\}, \\{b\\}, \\{a, b\\}, \\{a, b\\}\\}$
  - Number of subset: $|S| = 2 \longrightarrow 2^{2} = 2$

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<span id="cartesian"></span>

- ## Cartesian Product ( $\times$ )
  - The **Cartesian product** of **two sets**, which **itself** is a **set of ordered pairs**.
  - $S = S_1 \times S_2 = \\{(x, y) : x ‚àà S_1, y ‚àà S_2\\}$
  - For example: Let $S_1 = \\{2, 4\\}$ and $S_2 = \\{2, 3\\}$
  - $S_1 \times S_2 = \\{(2, 2), (2, 3), (4, 2), (4, 3)\\}$
  <br> 

  > **Note** that the order in which the elements of a pair are written matters.

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
  <span id="partition"></span>

- ## Partition
  - A **set** can be divided by separating it into a number of **subsets**. Suppose that **$S_1, S_2, ‚Ä¶, S_n$** are **subsets** of a given **set** **$S$** and that the following holds:
    - The **subsets** **$S_1, S_2, ‚Ä¶, S_n$** are **mutually disjoint**:
      - $S_1 \bigcap S_2 \bigcap ‚Ä¶ \bigcap S_n = \varnothing$ 
    <br>

    - $S_1 \bigcup S_2 \bigcup ‚Ä¶ \bigcup S_n = S$
    <br>

    - None of the **$S_i$** is **empty**:
        - $S_i \neq \varnothing$

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="function">Functions and Relations</h2>

- A **function** is a **rule** that assigns to elements of **one set** a **unique element of another set**. If **$f$** denotes a **function**, then the **first set** is called the **domain** of **$f$**, and the **second set** is its **range**.
  - $f: S_1 \rightarrow S_2$
<br>

- If the **domain** of **$f$** is **all of** **$S_1$**, we say that **$f$** is a **total function** on **$S_1$**; **otherwise** **$f$** is said to be a **partial function**.

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<h2 id="graphs">Graphs</h2>

<span id="edge"></span>

- ### Vertices & Edges
- A **graph** is a construct consisting of **two finite sets**:
  - **Vertices**: the **set** **$V = \\{v_1, v_2, ‚Ä¶, v_n\\}$**.
  - **Edges**: the **set** **$E = \\{e_1, e_2, ‚Ä¶, e_m\\}$**.
  - Each **edge** is a **pair** of **vertices** from **V**
    - $e_i = (v_j, v_k)$
<br>

  - We say that the **edge** **$e_i$** is an **outgoing edge** for **$v_j$** and an **incoming edge** for **$v_k$**. Such a construct is actually a **directed graph (digraph)**.

<span id="walk"></span>

- ### Walk
  - A **sequence of edges** **$(v_i, v_j)$**, **$(v_j, v_k)$**, ‚Ä¶, **$(v_m, v_n)$**, from **$v_i$** to **$v_n$**. 
  <br>

  - The **length of a walk** is the **total number of edges**.

<span id="path"></span>

- ### Path & Simple Path
  - A **walk** in which **no edge is repeated**.
  - A **path** is **simple** if **no vertex is repeated**.

<span id="cycle"></span>

- ### Cycle
  - A **walk** from **$v_i$** to **itself** with **no repeated** **edges** is called a **cycle with base** **$v_i$**.
  <br>  

  - If **no vertices** other than the **base** are **repeated** in a **cycle**, then it is said to be **simple**.
  <br>

  - **Loop**: An **edge** from a **vertex** to **itself**. 

<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<h2 id="tree">Trees</h2>

- **Trees** are a **particular type of graph**.
<br>

- **Tree** is a **directed graph** that has **no cycles** and that has **one distinct vertex**, called the **root**, such that there is **exactly one path** from the **root** to **every other vertex**. 
<br>

- **Root** has no **incoming edges** and that there are **some vertices without outgoing edges**. These are **called** the **leaves of the tree**.

<span id="child"></span>

- ### Parent & Child
  - If there is an **edge** from **$v_i$** to **$v_j$** , then **$v_i$** is said to be the **parent** of **$v_j$** , and **$v_j$** the **child** of **$v_i$**.

<span id="lvl"></span>

- ### Level
  - The **level** of a **vertex** is the **length of the path** from the **root** to the **vertex**.

<span id="height"></span>

- ### Height
  - The **height** of a **tree** is the **maximum level** of any **vertex** in the **tree**.
<br>
<img src="Pic/tree.jpg">
<br>
<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<h2 id="proof">Proof Techniques</h2>

<span id="proof1"></span>

- ### Proof By Induction
  - **Induction** is a **technique** by which the **truth of a number of statements** can be inferred from the **truth of a few specific instances**.
  <br>

  - **Basis**: 
  <br>

  - **Inductive Step**: 
  <br> 

  - **Inductive assumption**:

<span id="proof2"></span>

- ### Proof By Contradiction
  - **Proof by contradiction** is another **powerful technique** that often **works** when **everything else fails**.
  <br>

  - Suppose we want to **prove** that some **statement **$P$** is true**. We then **assume**, for the moment, that **$P$** is **false** and see where that assumption leads us. If we **arrive at a conclusion** that **we know is incorrect**, we can **lay** the blame on the starting assumption and conclude that **$P$** must be **true**.


<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>


<h1 id="languages">Languages</h1>

- **Dictionaries** define the term **informally** as a **system suitable** for the **expression of certain ideas**, **facts**, or **concepts**, **including a set of symbols and rules** for their manipulation.
<br>

- We start with a **finite**, **nonempty set** **$Œ£$** of **symbols**, called the **alphabet**. From the individual symbols we construct **strings**, which are **finite sequences of symbols from the alphabet**.
  <br> 

  - For example, if the **alphabet** **$Œ£ = \\{a, b\\}$**, then **abab** and **aaabbba** are **strings** on **$Œ£$**.
<br>

- We will use **lowercase letters** **a, b, c, ‚Ä¶** for **elements** of **$Œ£$** and **u, v, w, ‚Ä¶** for **string names**. 
  - **$w = abaaa$**, **string named** **$w$** has the **specific value** **$abaaa$**.
<br>

- The **concatenation** of **two strings** **$w$** and **$v$** is the **string** obtained by **appending the symbols** of **$v$** to the **right end** of **$w$**.
  <br>

  - **$w = a_1a_2 ‚ãØa_n$**, **$v = b_1b_2 ‚ãØb_m$**
  - The **concatenation** of **$w$** and **$v$**, denoted by **$wv$**:
    - **$wv = a_1a_2 ‚ãØa_nb_1b_2 ‚ãØb_m$**
  <br>

- The **reverse** of a **string** is obtained by **writing** the **symbols in reverse order**; if **$w$** is a **string** as shown above, then its **reverse** is **$w^R$**.
  - **$w = a_1a_2‚ãØa_n$**, **$w^R = a_n‚ãØa_2a_1$**
  <br>

- The **length of a string** **$w$**, denoted by **$|w|$**, is the **number of symbols** in the **string**. 
- The **empty string**, which is a **string** with **no symbols** at all. It will be denoted by **$Œª$**.
  - **$|Œª| = 0$**, **$Œªw = wŒª = w$**
<br>

- Any **string** of **consecutive symbols** in some **$w$** is said to be a **substring** of **$w$**.
  - **$w = vu$**
  - The **substrings** **$v$** and **$u$** are said to be a **prefix** and a **suffix** of **$w$**.
  <br>

  - For example, if **$w = abbab$**, then **$\\{Œª, a, ab, abb, abba, abbab\\}$** is the **set** of all **prefixes** of **$w$**, while **$bab$**, **$ab$**, **$b$** are some of its **suffixes**.
<br>


- If **$w$** is a **string**, then **$w^n$** stands for the **string obtained by repeating** **$w$**, **$n$** times.
  - **$w^3 = w.w.w$**, **$w^0 = Œª$**
<br>

- If **$Œ£$** is an **alphabet**, then we use **$Œ£^*$** to denote the **set of strings** obtained by **concatenating** **zero or more symbols from** **$Œ£$**. The **set** **$Œ£^*$** always **contains** **$Œª$**. To **exclude the empty string**:
  - **$Œ£^+ = Œ£^‚àó ‚àí \\{Œª\\}$**
  - While **$Œ£$** is **finite by assumption**, **$Œ£^*$** and **$Œ£^+$** are **always infinite** since there is **no limit on the length** of the **strings** in these sets.
<br>

- A **language** is defined very generally as a **subset** of **$Œ£^*$**. A **string** in a **language** **$L$** will be **called a sentence** of **$L$**.
<br>

- #### Example
  - Let **$Œ£ = \\{a, b\\}$**. Then **$Œ£^‚àó = \\{Œª, a, b, aa, ab, aab, ...\\}$**. The **set** **$\\{a, aa, aab\\}$** is a **language** on **$Œ£$**. Because it has a **finite number of sentences**, we call it a **finite language**. 
  <br>

  - The **set** **$L = \\{a^nb^n: n ‚â• 0\\}$** is also a **language** on **$Œ£$**. The **strings** **$aabb$** and **$aaaabbbb$** are in the **language** **$L$**, but the **string** **$abb$** is **not in** **$L$**. This **language is infinite**. **Most interesting languages are infinite**.
<br>

- Since **languages** are **sets**, the **union**, **intersection**, and **difference** of two languages are immediately defined.
<br>

- The **complement** of a **language** is defined with **respect** to **$Œ£^*$**; that is, the **complement** of **$L$** is: 
  - **$L = Œ£^‚àó ‚àí L$**
<br>

- The **reverse** of a **language** is the **set of all string reversals**, that is:
  - **$L^R = \\{w^R : w ‚àà L\\}$**
<br>

- The **concatenation** of two languages **$L_1$** and **$L_2$** is the **set** of all strings obtained by **concatenating** any element of **$L_1$** with any element of **$L_2$**; specifically:
  - **$L_1L_2 = \\{xy : x ‚àà L_1, y ‚àà L_2\\}$**
<br>

- We define **$L^n$** as **$L$** **concatenated** with itself **$n$** times: 
  - **$L^0 = \lambda$**
  - **$L^1 = L$**
<br>

- Define the **star-closure** of a **language** as:
  - **$L^‚àó = L^0 \bigcup L^1 \bigcup L^2 ‚ãØ$**
<br>

- Define the **positive closure** of a **language** as:
  - **$L^+ = L^1 \bigcup L^2 ‚ãØ$**


<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<h1 id="grammars">Grammars</h1>

- A **grammar** **$G$** is defined as a **quadruple**:
  - **$G = (V , T, S, P)$**
  <br>

  - **$V$** is a **finite set of objects** called **variables**.
  - **$T$** is a **finite set of objects** called **terminal symbols**.
  - **$S ‚àà V$** is a **special symbol** called the **start variable**
  - **$P$** is a **finite set of productions**.
  - **Assumed** that the **sets** **$V$** and **$T$** are **nonempty** and **disjoint**.
  <br>

- The **production rules** are the **heart of a grammar**; they **specify** **how the grammar transforms one string into another**, and through this they **define** a **language associated with the grammar**. 
<br>

- We will **assume** that **all production rules** are of the form:
  - **$x \rightarrow y$**
  - **$x$** is an **element of** **$(V ‚à™ T)^+$**  
  - **$y$** is **in** **$(V ‚à™ T)^*$**
<br>

- The **productions** are applied in the following manner:
  - We have a **string**: 
    - **$w = uxv$**
  - The **production** **$x ‚Üí y$** is applicable to this **string**.
  - The new **string** is:
    - **$z = uyv$**
  - We can write this as:
    - **$w \Rightarrow z$** 
    - We say that **$w$** **derives** **$z$** or that **$z$** is **derived** from **$w$**.
  <br>

- By applying the **production rules** in a **different order**, a **given grammar** can normally **generate many strings**. The **set** of all **such terminal strings** is the **language defined** or **generated by the grammar**.
<br>
 
- Let **$G = (V, T, S, P)$** be a **grammar**. 
  - **$L(G) = \\{w ‚àà T^‚àó: S \dot{\Rightarrow} w\\}$**
  - Is the **language** **generated by** **$G$**.
<br>

- If **$w ‚àà L(G)$**:
  - **$S ‚áí w1 ‚áí w2 ‚áí ‚ãØ ‚áí wn ‚áí w$**
  - The **sequence** is a **derivation** of the **sentence** **$w$**.
  - The **strings** **$S, w_1, w_2, ‚Ä¶, w_n$**, which **contain variables as well as terminals**, are called **sentential forms** of the **derivation**.
<br>

- #### Example
- The **grammer** is: **$G = (\\{S\\}, \\{a, b\\}, S, P)$**
- **$P$** given by: **$S ‚Üí aSb$**, **$S ‚Üí Œª$**.
- Then: **$S ‚áí aSb ‚áí aaSbb ‚áí aabb$**
- We can write: **$S \dot{\Rightarrow} aabb$**
- The **string** **$aabb$** is a **sentence** in the **language generated by** **$G$**, while **$aaSbb$** is a **sentential form**.
<br>

- A **grammar** **$G$** **completely defines** **$L(G)$**, but it may not be easy to get a very explicit description of the language from the grammar. Here, however, the answer is fairly clear. It is not hard to conjecture that: 
  - **$L(G) = \\{a^nb^n: n ‚â• 0\\}$**
<br>

- Normally, a given **language** has **many grammars** that generate it. Even though these grammars are different, they are **equivalent** in some sense. 
- We say that **two grammars** **$G_1$** and **$G_2$** are **equivalent** if they **generate the same language**:
  - **$L(G_1) = L(G_2)$**


<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<h1 id="automata">Automata</h1>

- An **automaton** is an **abstract model of a digital computer**. As such, **every automaton** includes **some essential features**. It has a **mechanism for reading input**. It will be **assumed** that the **input is a string over a given alphabet**, **written on an input file**, which the **automaton** can **read but not change**.
<br>

- The **input file** is **divided into cells**, each of which can **hold one symbol**. The **input mechanism** can **read the input file** from **left to right**, **one symbol at a time**. The **input mechanism** can also **detect** the **end of the input string** (by sensing an **end-of-file condition**).
<br>

- The **automaton** can **produce output of some form**. It may have a **temporary storage device**, **consisting of an unlimited number of cells**, each **capable of holding a single symbol from an alphabet** (not necessarily the same one as the input alphabet).
<br>

- The **automaton** can **read and change** the **contents of the storage cells**. **Finally**, the **automaton has a control unit**, which can be in any one of a **finite number of internal states**, and which can **change state** in some defined manner.
<br>
<img src="Pic/automation.jpg">
<br>

- An **automaton** is **assumed** to **operate** in a **discrete time frame**. **At any given time**, the **control unit** is in some **internal state**, and the **input mechanism** is **scanning a particular symbol on the input file**. The **internal state of the control unit** at the **next time step** is determined by the **next-state** or **transition function**.
<br>

- The **transition function** gives the **next state** in **terms of the current state**, the **current input symbol**, and the **information currently** in the **temporary storage**. During the **transition from one time interval to the next**, **output** may be **produced** or the **information in the temporary storage changed**.
<br>

- The **term configuration** will be used to refer to a **particular state of the control unit**, **input file**, and **temporary storage**. The **transition of the automaton** from **one configuration to the next** will be called a **move**.
<br>






<div align="right"><a href="#topp" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
